<body>
    <canvas id="graph-canvas" width="800" height="800">

    </canvas>
    <script type="text/javascript">
        const timeFunc = (f, n) => {
            const timeStats = { avg: null, timesCalled: 0 }
            return [(...args) => {
                const stime = performance.now();
                f.apply({}, args);
                const duration = performance.now() - stime;
                if (timeStats.avg == 0) {
                    timeStats.avg = duration;
                } else {
                    timeStats.avg = (timeStats.avg * timeStats.timesCalled + duration) / (timeStats.timesCalled + 1);
                    timeStats.timesCalled += 1;
                }
                //console.log(`Function ${n} took ${duration} avg ${timeStats.avg}`)
            }, timeStats];
        }

        const numNodes = 1500;
        const numEdges = 1500;
        class Node {
            constructor(inX, inY) {
                this.x = inX;
                this.y = inY;
                this.dx = 0;
                this.dy = 0;
                this.connected = 0;
            }
        }
        let nodes = [];
        let edges = []
        const [initGraph, initGraphTimeStats] = timeFunc(() => {
            for (let i = 0; i < numNodes; i++) {
                nodes.push(new Node(Math.random(), Math.random()));
            }
            for (let i = 0; i < numEdges; i++) {
                const head = nodes[Math.floor(Math.random() * numNodes)];
                const tail = nodes[Math.floor(Math.random() * numNodes)];
                edges.push([head, tail]);
                head.connected = 1;
                tail.connected = 1;
            }
        }, "initGraph")
        initGraph();

        const twoPI = 2 * Math.PI;

        const repulsion = 0.000001;
        const attraction = 0.01;
        const centering = 0.007;
        const friction = 0.5
        const epsilon = 0.0001;
        const connectedCentering = 0.007; //center by this much more if the node has edges

        const repulsionSparsity = 5;
        const sparseRepulsion = repulsion * repulsionSparsity;
        const [move, moveTimeStats] = timeFunc(() => {
            edges.forEach(([a, b]) => {
                const accX = (a.x - b.x) * attraction;
                const accY = (a.y - b.y) * attraction;
                a.dx -= accX;
                b.dx += accX;
                a.dy -= accY;
                b.dy += accY;
            });
            nodes.forEach((a, idx) => {
                const sparsePhase = (moveTimeStats.timesCalled + idx) % repulsionSparsity;
                a.dx -= (a.x - 0.5) * (centering + a.connected * connectedCentering);
                a.dy -= (a.y - 0.5) * (centering + a.connected * connectedCentering);
                for (let i = 0; i < numNodes / 5; i++) {
                    const b = nodes[sparsePhase + i * repulsionSparsity];
                    if (a !== b) {
                        const distSquared = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + epsilon;
                        const accX = (a.x - b.x) * sparseRepulsion / distSquared;
                        const accY = (a.y - b.y) * sparseRepulsion / distSquared;
                        a.dx += accX;
                        b.dx -= accX;
                        a.dy += accY;
                        b.dy -= accY;
                    }
                }
                // nodes.forEach((b) => {
                //     if (a !== b) {
                //         const distSquared = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + epsilon;
                //         const accX = (a.x - b.x) * repulsion / distSquared;
                //         const accY = (a.y - b.y) * repulsion / distSquared;
                //         a.dx += accX;
                //         b.dx -= accX;
                //         a.dy += accY;
                //         b.dy -= accY;
                //     }
                // });
                a.x += a.dx;
                a.y += a.dy;
                a.dx *= friction;
                a.dy *= friction;
            });
        }, "move");

        const canvas = document.getElementById("graph-canvas");
        const ctx = canvas.getContext("2d");
        ctx.scale(canvas.width, canvas.height);

        const [render, renderTimeStats] = timeFunc(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "red";
            ctx.lineWidth = 0.001;
            edges.forEach(([node, endNode]) => {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(endNode.x, endNode.y);
                ctx.stroke();
            })
            ctx.fillStyle = "green";
            nodes.forEach((node) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 0.01, 0, twoPI, false);
                ctx.fill();
            })
        }, "render");

        const update = (timestamp) => {
            move();
            render();
            requestAnimationFrame(update);
        }

        let lastMoveTime = performance.now();
        let timesMoved = 0;
        let avgMoveTime = null;
        window.requestAnimationFrame(update);
        const asyncChainMove = () => {
            const newMoveTime = performance.now();
            const duration = newMoveTime - lastMoveTime;
            if (avgMoveTime == 0) {
                avgMoveTime = duration;
            } else {
                avgMoveTime = (avgMoveTime * timesMoved + duration) / (timesMoved + 1);
                timesMoved += 1;
            }
            move();
            setTimeout(asyncChainMove, 0);
        }
        //asyncChainMove();
    </script>
</body>