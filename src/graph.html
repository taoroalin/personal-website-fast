<body style="padding:0;margin:0;">
    <canvas id="graph-canvas" width="936" height="969" tabindex="0">

    </canvas>
    <script type="text/javascript">

        /**
         * Creates a version of a function that keeps track of avg and variance in runtime.
         * Meant to be used like this: 
         * const [func, funcTimeStats]=timeFunc(()=>{...}, "func")
         * Optionally prints time stats every time func is called
         */
        const timeFunc = (f, n = "", print = false) => {
            const timeStats = { avg: null, timesCalled: 0, std: 0, variance: 0 }
            return [(...args) => {
                const stime = performance.now();
                f.apply({}, args);
                const duration = performance.now() - stime;
                if (timeStats.avg == 0) {
                    timeStats.avg = duration;
                } else {
                    timeStats.avg = (timeStats.avg * timeStats.timesCalled + duration) / (timeStats.timesCalled + 1);
                    const deviationNow = (timeStats.avg - duration) * (timeStats.avg - duration);
                    timeStats.variance = (timeStats.variance * (timeStats.timesCalled) + deviationNow) / (timeStats.timesCalled + 1);
                    timeStats.std = Math.sqrt(timeStats.variance);
                    timeStats.timesCalled += 1;
                }
                if (print) {
                    console.log(`Function ${n} took ${duration} avg ${timeStats.avg}`)
                }
            }, timeStats];
        }

        // testing paramameters
        let numNodes = 2000;
        const numEdges = 2000;
        const numBuckets = 8; // grid of buckets 8 wide, 64 buckets total
        class Node {
            constructor(inX, inY) {
                this.x = inX;
                this.y = inY;
                this.dx = 0;
                this.dy = 0;
                this.ax = 0; // acceleration for smoothing
                this.ay = 0;
                this.connected = false;
            }
        }

        // Mutable state
        let nodes = [];
        let edges = [];
        let buckets;
        const canvas = document.getElementById("graph-canvas");
        const ctx = canvas.getContext("2d");
        ctx.scale(canvas.width, canvas.height);
        let mousePosition = { x: 0, y: 0, prevX: 0, prevY: 0 };
        let updating = true;

        // this is set to a listener when mouse clicks, removed when mouse is released
        let [mouseMoveListener, mouseMoveListenerTimeStats] = timeFunc((event) => {
            mousePosition.x = event.offsetX;
            mousePosition.y = event.offsetY;
            // mousemove event isn't very fast. Could extrapolate future position to make it feel more responsive
        });

        const [initGraph, initGraphTimeStats] = timeFunc(() => {
            for (let i = 0; i < numNodes; i++) {
                nodes.push(new Node(Math.random(), Math.random()));
            }
            for (let i = 0; i < numEdges; i++) {
                const head = nodes[Math.floor(Math.random() * numNodes)];
                const tail = nodes[Math.floor(Math.random() * numNodes)];
                if (head != tail) {
                    edges.push([head, tail]);
                    head.connected = true;
                    tail.connected = true;
                }
            }
            nodes = nodes.filter((x) => x.connected);
            numNodes = nodes.length;
            buckets = [...Array(numBuckets)].map(i => [...Array(numBuckets)].map(j => []))
            // (repeat num-buckets (repeat num-buckets [])) cljs would be more concise

            canvas.addEventListener("mousedown", (event) => {
                mousePosition = { x: event.offsetX, y: event.offsetY, prevX: event.offsetX, prevY: event.offsetY };
                canvas.addEventListener("mousemove", mouseMoveListener)
            })
            canvas.addEventListener("mouseup", (event) => {
                canvas.removeEventListener("mousemove", mouseMoveListener)
            })
            canvas.addEventListener("mouseleave", (event) => {
                canvas.removeEventListener("mousemove", mouseMoveListener)
            })
            canvas.addEventListener("keypress", (event) => {
                console.log(event.code);
                if (event.code == "Space") {
                    updating = !updating;
                }
            })
        }, "initGraph")
        initGraph();

        const twoPI = 2 * Math.PI;
        const attraction = 0.2;
        const centering = 0.005;
        const friction = 0.5
        const epsilon = 0.0001;
        const repulsion = 0.0002;
        const numBucketPositions = 3;
        const repulsionSmoothing = 0.99;
        const repulsionMultiplier = (1 - repulsionSmoothing) * repulsion / numBucketPositions;

        const [bucket, bucketTimeStats] = timeFunc(() => {
            // clear buckets
            buckets.forEach(row => row.forEach(bucket => bucket.length = 0));
            const offset = (Math.random() - 0.5) / numBuckets;
            nodes.forEach(node => {
                // could switch to bit shifting, but wouldn't work with doubles
                const x = Math.floor((node.x + offset) * numBuckets);
                const y = Math.floor((node.y + offset) * numBuckets);
                if (0 < x && x < numBuckets && 0 < y && y < numBuckets) {
                    buckets[x][y].push(node);
                }
            })
            buckets.forEach(row => row.forEach(bucket => bucket.forEach(a => bucket.forEach(b => {
                const distSquared = Math.abs((a.x - b.x) * (a.x - b.x) * (a.x - b.x)) + Math.abs((a.y - b.y) * (a.y - b.y) * (a.y - b.y)) + epsilon;
                const accX = (a.x - b.x) / distSquared * repulsionMultiplier;
                const accY = (a.y - b.y) / distSquared * repulsionMultiplier;
                a.ax = a.ax * repulsionSmoothing + accX;
                b.ax = b.ax * repulsionSmoothing - accX;
                a.ay = a.ay * repulsionSmoothing + accY;
                b.ay = b.ay * repulsionSmoothing - accY;
                // a.dx += accX;
                // b.dx -= accX;
                // a.dy += accY;
                // b.dy -= accY;
            }))))
        }, "bucket");

        const [move, moveTimeStats] = timeFunc(() => {
            edges.forEach(([a, b]) => {
                const distSquared = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + epsilon;
                const accX = (a.x - b.x) * attraction;
                const accY = (a.y - b.y) * attraction;
                a.dx -= accX;
                b.dx += accX;
                a.dy -= accY;
                b.dy += accY;
            });
            nodes.forEach((a) => {
                a.dx -= (a.x - 0.5) * centering;
                a.dy -= (a.y - 0.5) * centering;
                a.dx += a.ax;
                a.dy += a.ay;
                a.x += a.dx;
                a.y += a.dy;
                a.dx *= friction;
                a.dy *= friction;
            });
        }, "move");

        const [render, renderTimeStats] = timeFunc(() => {
            // clear canvas in positive and negative directions
            ctx.save();
            ctx.translate(-5000, -5000);
            ctx.clearRect(0, 0, 10000, 10000);
            ctx.restore();

            ctx.translate((mousePosition.x - mousePosition.prevX) / 936, (mousePosition.y - mousePosition.prevY) / 969);
            mousePosition.prevX = mousePosition.x;
            mousePosition.prevY = mousePosition.y;
            // draw lines first so they go underneath nodes
            ctx.fillStyle = "red";
            ctx.lineWidth = 0.002;
            edges.forEach(([node, endNode]) => {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(endNode.x, endNode.y);
                ctx.stroke();
            })

            // draw nodes
            ctx.fillStyle = "green";
            nodes.forEach((node) => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 0.007, 0, twoPI, false);
                ctx.fill();
            })
        }, "render");

        const [update, updateTimeStats] = timeFunc((timestamp) => {
            if (updating) {
                for (let i = 0; i < numBucketPositions; i++) {
                    bucket();
                }
                move();
            }
            render();
            requestAnimationFrame(update);
        }, "update");
        window.requestAnimationFrame(update);
    </script>
    <script>
        const unionFindByEdges = (edges, numNodes) => {
            const result = [];
            resul
            const find = (x) => {
                if (result[x] === undefined) {
                    result[x] = x;
                }
                if (x !== result[x]) {
                    result[x] = find(result[x]);
                }
                return result[x];
            }
            const union = (a, b) => {
                result[find(a)] = find(b);
            }

            edges.forEach(([a, b]) => union(a, b));

            for (let i = 0; i < result.length; i++) {
                if (result[i] === undefined) {
                    result[i] = i;
                }
            }
            return result;
        }
        console.log(unionFindByEdges([[1, 2], [3, 4]]))
    </script>
    <script>
        /**
         * is this how octree colision optimization works?
         */

    </script>
</body>