<body style="padding:0;margin:0;">
    <canvas id="graph-canvas" width="936" height="969" tabindex="0" style="outline:none">

    </canvas>
    <script type="text/javascript">

        /**
         * Creates a version of a function that keeps track of avg and variance in runtime.
         * Meant to be used like this: 
         * const [func, funcTimeStats]=timeFunc(()=>{...}, "func")
         * Optionally prints time stats every time func is called
         */
        const timeFunc = (f, n = "", print = false) => {
            const timeStats = { avg: null, timesCalled: 0, std: 0, variance: 0 }
            return [(...args) => {
                const stime = performance.now();
                f.apply({}, args);
                const duration = performance.now() - stime;
                if (timeStats.avg == 0) {
                    timeStats.avg = duration;
                } else {
                    timeStats.avg = (timeStats.avg * timeStats.timesCalled + duration) / (timeStats.timesCalled + 1);
                    const deviationNow = (timeStats.avg - duration) * (timeStats.avg - duration);
                    timeStats.variance = (timeStats.variance * (timeStats.timesCalled) + deviationNow) / (timeStats.timesCalled + 1);
                    timeStats.std = Math.sqrt(timeStats.variance);
                    timeStats.timesCalled += 1;
                }
                if (print) {
                    console.log(`Function ${n} took ${duration} avg ${timeStats.avg}`)
                }
            }, timeStats];
        }

        // testing paramameters
        const numNodes = 2000;
        const numEdges = 2000;

        // Mutable state
        const nodeXs = new Float32Array(numNodes);
        const nodeYs = new Float32Array(numNodes);
        const nodeDXs = new Float32Array(numNodes);
        const nodeDYs = new Float32Array(numNodes);
        const edgeStarts = new Int32Array(numEdges);
        const edgeEnds = new Int32Array(numEdges);

        const canvas = document.getElementById("graph-canvas");
        const ctx = canvas.getContext("2d");
        ctx.scale(canvas.width, canvas.height);

        let mousePosition = [];
        let canvasPosition = { x: 0, y: 0 };
        let updating = true;

        // this is set to a listener when mouse clicks, removed when mouse is released
        let [mouseMoveListener, mouseMoveListenerTimeStats] = timeFunc((event) => {
            mousePosition[mousePosition.length - 1] = { x: event.offsetX, y: event.offsetY };
            // mousemove event isn't very fast. Could extrapolate future position to make it feel more responsive
        });

        const [initGraph, initGraphTimeStats] = timeFunc(() => {
            for (let i = 0; i < numNodes; i++) {
                nodeXs[i] = Math.random();
                nodeYs[i] = Math.random();
            }
            for (let i = 0; i < numEdges; i++) {
                const head = Math.floor(Math.random() * numNodes);
                const tail = Math.floor(Math.random() * numNodes);
                edgeStarts[i] = head;
                edgeEnds[i] = tail;
            }

            canvas.addEventListener("mousedown", (event) => {
                mousePosition = [{ x: event.offsetX, y: event.offsetY }];
                canvas.addEventListener("mousemove", mouseMoveListener)
            })
            canvas.addEventListener("mouseup", (event) => {
                canvas.removeEventListener("mousemove", mouseMoveListener)
            })
            canvas.addEventListener("mouseleave", (event) => {
                canvas.removeEventListener("mousemove", mouseMoveListener)
            })
            canvas.addEventListener("keypress", (event) => {
                if (event.code == "Space") {
                    updating = !updating;
                    event.stopPropagation();
                }
            })
        }, "initGraph")
        initGraph();

        const twoPI = 2 * Math.PI;
        const attraction = 0.2;
        const centering = 0.005;
        const friction = 0.5
        const epsilon = 0.0001;
        const repulsion = 0.000005;
        const numBucketPositions = 3;
        const repulsionSmoothing = 0.99;
        const repulsionMultiplier = (1 - repulsionSmoothing) * repulsion / numBucketPositions;


        const [move, moveTimeStats] = timeFunc(() => {
            for (let i = 0; i < numEdges; i++) {
                const dx = (nodeXs[edgeStarts[i]] - nodeXs[edgeEnds[i]]);
                const dy = (nodeYs[edgeStarts[i]] - nodeYs[edgeEnds[i]]);
                const distSquared = dx * dx + dy * dy + epsilon;
                const accX = dx * attraction;
                const accY = dy * attraction;
                nodeDXs[edgeStarts[i]] -= accX;
                nodeDXs[edgeEnds[i]] += accX;
                nodeDYs[edgeStarts[i]] -= accY;
                nodeDYs[edgeEnds[i]] += accY;
            }
            for (let i = 0; i < numNodes; i++) {
                nodeXs[i] -= (nodeXs[i] - 0.5) * centering;
                nodeYs[i] -= (nodeXs[i] - 0.5) * centering;
                for (let j = 0; j < numNodes; j++) {
                    const dx = (nodeXs[i] - nodeXs[j]) * repulsion;
                    const dy = (nodeYs[i] - nodeYs[j]) * repulsion;
                    nodeDXs[i] += dx;
                    nodeDXs[j] -= dx;
                    nodeDYs[i] += dy;
                    nodeDYs[j] -= dy;
                }
                nodeXs[i] += nodeDXs[i];
                nodeYs[i] += nodeDYs[i];
                nodeDXs[i] *= friction;
                nodeDYs[i] *= friction;
            }
        }, "move");

        const proj = 4;

        const projectMouse = () => {
            const numPositions = mousePosition.length;
            const positions = mousePosition;
            const predictedPosition = {};
            if (numPositions == 1) {
                return (positions[0]);

            } else if (numPositions == 2) {

                let deltaX = positions[1].x - positions[0].x;
                let deltaY = positions[1].y - positions[0].y;

                predictedPosition.x = positions[1].x + deltaX;
                predictedPosition.y = positions[1].y + deltaY;

            } else if (numPositions == 3) {

                let sumOfXChanges = ((positions[2].x - positions[1].x) * 2) +
                    ((positions[1].x - positions[0].x) * 1);

                let deltaX = sumOfXChanges / 3.0;

                let sumOfYChanges = ((positions[2].y - positions[1].y) * 2) +
                    ((positions[1].y - positions[0].y) * 1);

                let deltaY = sumOfYChanges / 3.0;

                predictedPosition.x = positions[positions.length - 1].x + deltaX;
                predictedPosition.y = positions[positions.length - 1].y + deltaY;

            } else if (numPositions == 4) {

                let sumOfXChanges = ((positions[3].x - positions[2].x) * 3) +
                    ((positions[2].x - positions[1].x) * 2) +
                    ((positions[1].x - positions[0].x) * 1);

                let deltaX = sumOfXChanges / 6.0;

                let sumOfYChanges = ((positions[3].y - positions[2].y) * 3) +
                    ((positions[2].y - positions[1].y) * 2) +
                    ((positions[1].y - positions[0].y) * 1);

                let deltaY = sumOfYChanges / 6.0;

                predictedPosition.x = positions[positions.length - 1].x + deltaX;
                predictedPosition.y = positions[positions.length - 1].y + deltaY;

            } else if (numPositions >= 5) {

                let sumOfXChanges = ((positions[numPositions - 1].x - positions[numPositions - 2].x) * 4) +
                    ((positions[numPositions - 2].x - positions[numPositions - 3].x) * 3) +
                    ((positions[numPositions - 3].x - positions[numPositions - 4].x) * 2) +
                    ((positions[numPositions - 4].x - positions[numPositions - 5].x) * 1);

                let deltaX = sumOfXChanges / 10.0;

                let sumOfYChanges = ((positions[numPositions - 1].y - positions[numPositions - 2].y) * 4) +
                    ((positions[numPositions - 2].y - positions[numPositions - 3].y) * 3) +
                    ((positions[numPositions - 3].y - positions[numPositions - 4].y) * 2) +
                    ((positions[numPositions - 4].y - positions[numPositions - 5].y) * 1);

                let deltaY = sumOfYChanges / 10.0;

                predictedPosition.x = positions[positions.length - 1].x + deltaX;
                predictedPosition.y = positions[positions.length - 1].y + deltaY;

            }
            return predictedPosition;
        }

        const [render, renderTimeStats] = timeFunc(() => {
            // clear canvas in positive and negative directions
            ctx.save();
            ctx.translate(-5000, -5000);
            ctx.clearRect(0, 0, 10000, 10000);
            ctx.restore();

            // Mouse dragging whole canvas
            const lastIdx = mousePosition.length - 1;
            const cur = mousePosition[lastIdx];
            const prev = mousePosition[lastIdx - 1];
            if (cur && prev) {
                canvasPosition.x += (cur.x - prev.x);
                canvasPosition.y += (cur.y - prev.y);

                const proj = projectMouse();
                //ctx.setTransform(936, 10, 0, 969, canvasPosition.x, canvasPosition.y);
                ctx.setTransform(936, 10, 0, 969, canvasPosition.x + (proj.x - cur.x) * 1.5, canvasPosition.y + (proj.y - cur.y) * 1.5);
            }
            mousePosition.push(mousePosition[mousePosition.length - 1]);

            // draw lines first so they go underneath nodes
            ctx.fillStyle = "red";
            ctx.lineWidth = 0.002;
            for (let i = 0; i < numEdges; i++) {
                ctx.beginPath();
                ctx.moveTo(nodeXs[edgeStarts[i]], nodeYs[edgeStarts[i]]);
                ctx.lineTo(nodeXs[edgeEnds[i]], nodeYs[edgeEnds[i]]);
                // console.log(`sx ${sx} sy ${sy} ex ${ex} ${ey}`);
                ctx.stroke();
            }

            // draw nodes
            ctx.fillStyle = "green";
            for (let i = 0; i < numNodes; i++) {
                ctx.beginPath();
                ctx.arc(nodeXs[i], nodeYs[i], 0.007, 0, twoPI, false);
                ctx.fill();
            }
        }, "render");

        const [update, updateTimeStats] = timeFunc((timestamp) => {
            if (updating) {
                move();
            }
            render();
            requestAnimationFrame(update);
        }, "update");
        window.requestAnimationFrame(update);
    </script>

    <script>
        const unionFindByEdges = (edges, numNodes) => {
            const result = [...Array(numNodes).keys()];
            const find = (x) => {
                if (result[x] === undefined) {
                    result[x] = x;
                }
                if (x !== result[x]) {
                    result[x] = find(result[x]);
                }
                return result[x];
            }
            const union = (a, b) => {
                result[find(a)] = find(b);
            }
            edges.forEach(([a, b]) => union(a, b));
            return result;
        }
        console.log(unionFindByEdges([[1, 2], [3, 4]]))
    </script>
    <script>
        /**
         * is this how octree colision optimization works?
         */

    </script>
</body>